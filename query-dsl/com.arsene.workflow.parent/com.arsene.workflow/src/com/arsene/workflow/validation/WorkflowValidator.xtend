/*
 * generated by Xtext 2.25.0
 */
package com.arsene.workflow.validation

import com.arsene.workflow.workflow.WorkflowPackage
import com.google.inject.Inject
import org.eclipse.xtext.validation.Check
import com.arsene.workflow.typing.WorkflowTypeComputer
import com.arsene.workflow.workflow.Not
import com.arsene.workflow.workflow.Expression
import com.arsene.workflow.typing.ExpressionsType
import org.eclipse.emf.ecore.EReference
import com.arsene.workflow.workflow.And
import com.arsene.workflow.workflow.Or
import com.arsene.workflow.workflow.MulOrDiv
import com.arsene.workflow.workflow.Minus
import com.arsene.workflow.workflow.Equality
import com.arsene.workflow.workflow.Comparison
import com.arsene.workflow.workflow.Plus
import com.arsene.workflow.workflow.VariableRef
import com.arsene.workflow.workflow.Method
import com.arsene.workflow.workflow.MethodInvocation
import java.lang.invoke.MethodHandles.Lookup
import com.arsene.workflow.workflow.Variable
import com.arsene.workflow.workflow.Workflow

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class WorkflowValidator extends AbstractWorkflowValidator {

	public static val PACKAGE_NAME = "com.arsene.workflow."
	public static val WORKFLOW_INVALID_NAME = PACKAGE_NAME + "InvalidWorkflowName"
	public static val METHOD_INVALID_NAME = PACKAGE_NAME + "InvalidMethodName"
	public static val VARIABLE_INVALID_NAME = PACKAGE_NAME + "InvalidVariableName"

	public static val FORWARD_REFERENCE = PACKAGE_NAME + "ForwardReference"
	public static val TYPE_MISMATCH = PACKAGE_NAME + "TypeMismatch"
	public static val INVALID_ARGS = PACKAGE_NAME + "InvalidArgs"

	@Inject extension WorkflowModelUtil
	@Inject extension WorkflowTypeComputer

	@Check
	def checkWorkflowNameStartsWithLowerLetter(Variable variable) {
		if (Character.isUpperCase(variable.name.charAt(0)))
			warning(
				"Variable name should start with a small letter",
				WorkflowPackage.eINSTANCE.variable_Name,
				VARIABLE_INVALID_NAME,
				variable.name
			)
	}

	@Check
	def checkUndefinedVariable(Variable variable) {
//		if (Character.isUpperCase(variable.name.charAt(0)))
//			warning(
//				"Variable name should start with a small letter",
//				WorkflowPackage.eINSTANCE.variable_Name,
//				VARIABLE_INVALID_NAME,
//				variable.name
//			)
		if (variable.expression instanceof VariableRef) {

			val varName = variable.name
			var varRefName = (variable.expression as VariableRef).variable.name

			if (varName === varRefName) {
				warning(
					"Variable should be defined before its use",
					null,
					varRefName
				)
			}

		}
	}

	@Check
	def checkWorkflowNameStartsWithLowerLetter(Workflow workflow) {
		if (Character.isUpperCase(workflow.name.charAt(0)))
			warning(
				"Workflow name should start with a small letter",
				WorkflowPackage.eINSTANCE.workflow_Name,
				WORKFLOW_INVALID_NAME,
				workflow.name
			)
	}

	@Check
	def checkMethodStartsWithSmallLetter(Method method) {
		if (Character.isUpperCase(method.name.charAt(0)))
			warning(
				"Method name should start with a small letter",
				WorkflowPackage.eINSTANCE.method_Name,
				METHOD_INVALID_NAME,
				method.name
			)
	}

	@Check
	def void checkMethodInvocationArguments( MethodInvocation methodInvoc) {
		val method = methodInvoc.invokedMethod

		if (method.params.size != methodInvoc.args.size) {
			error("Invalid number of arguments: expected " + method.params.size + " but was " + methodInvoc.args.size,
				WorkflowPackage.eINSTANCE.methodInvocation_InvokedMethod, INVALID_ARGS)
		}
	}

	@Check
	def void checkForwardReference(VariableRef varRef) {
		val variable = varRef.variable

		if (variable.name === null)
			error(
				"variable forward reference not allowed: '" + variable.name + "'",
				WorkflowPackage.eINSTANCE.variableRef_Variable,
				FORWARD_REFERENCE,
				variable.name
			)
	}

	@Check def checkType(Not not) {
		checkExpectedBoolean(not.expression, WorkflowPackage.Literals.NOT__EXPRESSION)
	}

	@Check def checkType(And and) {
		checkExpectedBoolean(and.left, WorkflowPackage.Literals.AND__LEFT)
		checkExpectedBoolean(and.right, WorkflowPackage.Literals.AND__RIGHT)
	}

	@Check
	def checkType(Or or) {
		checkExpectedBoolean(or.left, WorkflowPackage.Literals.OR__LEFT)
		checkExpectedBoolean(or.right, WorkflowPackage.Literals.OR__RIGHT)
	}

	@Check
	def checkType(MulOrDiv mulOrDiv) {
		checkExpectedInt(mulOrDiv.left, WorkflowPackage.Literals.MUL_OR_DIV__LEFT)
		checkExpectedInt(mulOrDiv.right, WorkflowPackage.Literals.MUL_OR_DIV__RIGHT)
	}

	@Check
	def checkType(Minus minus) {
		checkExpectedInt(minus.left, WorkflowPackage.Literals.MINUS__LEFT)
		checkExpectedInt(minus.right, WorkflowPackage.Literals.MINUS__RIGHT)
	}

	@Check def checkType(Equality equality) {
		val leftType = getTypeAndCheckNotNull(equality.left, WorkflowPackage.Literals.EQUALITY__LEFT)
		val rightType = getTypeAndCheckNotNull(equality.right, WorkflowPackage.Literals.EQUALITY__RIGHT)
		checkExpectedSame(leftType, rightType)
	}

	@Check def checkType(Comparison comparison) {
		val leftType = getTypeAndCheckNotNull(comparison.left, WorkflowPackage.Literals.COMPARISON__LEFT)
		val rightType = getTypeAndCheckNotNull(comparison.right, WorkflowPackage.Literals.COMPARISON__RIGHT)
		checkExpectedSame(leftType, rightType)
		checkNotBoolean(leftType, WorkflowPackage.Literals.COMPARISON__LEFT)
		checkNotBoolean(rightType, WorkflowPackage.Literals.COMPARISON__RIGHT)
	}

	@Check def checkType(Plus plus) {
		val leftType = getTypeAndCheckNotNull(plus.left, WorkflowPackage.Literals.PLUS__LEFT)
		val rightType = getTypeAndCheckNotNull(plus.right, WorkflowPackage.Literals.PLUS__RIGHT)
		if (leftType.isIntType || rightType.isIntType || (!leftType.isStringType && !rightType.isStringType)) {
			checkNotBoolean(leftType, WorkflowPackage.Literals.PLUS__LEFT)
			checkNotBoolean(rightType, WorkflowPackage.Literals.PLUS__RIGHT)
		}
	}

	def private checkExpectedSame(ExpressionsType left, ExpressionsType right) {
		if (right !== null && left !== null && right != left) {
			error("expected the same type, but was " + left + ", " + right,
				WorkflowPackage.Literals.EQUALITY.getEIDAttribute(), TYPE_MISMATCH)
		}
	}

	def private checkNotBoolean(ExpressionsType type, EReference reference) {
		if (type.isBoolType) {
			error("cannot be boolean", reference, TYPE_MISMATCH)
		}
	}

	def private checkExpectedBoolean(Expression exp, EReference reference) {
		checkExpectedType(exp, WorkflowTypeComputer.BOOL_TYPE, reference)
	}

	def private checkExpectedInt(Expression exp, EReference reference) {
		checkExpectedType(exp, WorkflowTypeComputer.INT_TYPE, reference)
	}

	def private checkExpectedType(Expression exp, ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error(
				"expected " + expectedType + " type, but was " + actualType,
				reference,
				TYPE_MISMATCH
			)
	}

	def private ExpressionsType getTypeAndCheckNotNull(Expression exp, EReference reference) {
		val type = exp?.typeFor
		if (type === null)
			error("null type", reference, TYPE_MISMATCH)
		return type;
	}
}
