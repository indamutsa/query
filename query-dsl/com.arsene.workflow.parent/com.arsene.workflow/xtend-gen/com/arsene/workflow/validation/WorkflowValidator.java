/**
 * generated by Xtext 2.25.0
 */
package com.arsene.workflow.validation;

import com.arsene.workflow.typing.ExpressionsType;
import com.arsene.workflow.typing.WorkflowTypeComputer;
import com.arsene.workflow.workflow.And;
import com.arsene.workflow.workflow.Comparison;
import com.arsene.workflow.workflow.Equality;
import com.arsene.workflow.workflow.Expression;
import com.arsene.workflow.workflow.Method;
import com.arsene.workflow.workflow.MethodInvocation;
import com.arsene.workflow.workflow.Minus;
import com.arsene.workflow.workflow.MulOrDiv;
import com.arsene.workflow.workflow.Not;
import com.arsene.workflow.workflow.Or;
import com.arsene.workflow.workflow.Plus;
import com.arsene.workflow.workflow.Variable;
import com.arsene.workflow.workflow.VariableRef;
import com.arsene.workflow.workflow.Workflow;
import com.arsene.workflow.workflow.WorkflowPackage;
import com.google.common.base.Objects;
import com.google.inject.Inject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class WorkflowValidator extends AbstractWorkflowValidator {
  public static final String PACKAGE_NAME = "com.arsene.workflow.";
  
  public static final String WORKFLOW_INVALID_NAME = (WorkflowValidator.PACKAGE_NAME + "InvalidWorkflowName");
  
  public static final String METHOD_INVALID_NAME = (WorkflowValidator.PACKAGE_NAME + "InvalidMethodName");
  
  public static final String VARIABLE_INVALID_NAME = (WorkflowValidator.PACKAGE_NAME + "InvalidVariableName");
  
  public static final String FORWARD_REFERENCE = (WorkflowValidator.PACKAGE_NAME + "ForwardReference");
  
  public static final String TYPE_MISMATCH = (WorkflowValidator.PACKAGE_NAME + "TypeMismatch");
  
  public static final String INVALID_ARGS = (WorkflowValidator.PACKAGE_NAME + "InvalidArgs");
  
  @Inject
  @Extension
  private WorkflowModelUtil _workflowModelUtil;
  
  @Inject
  @Extension
  private WorkflowTypeComputer _workflowTypeComputer;
  
  @Check
  public void checkWorkflowNameStartsWithLowerLetter(final Variable variable) {
    boolean _isUpperCase = Character.isUpperCase(variable.getName().charAt(0));
    if (_isUpperCase) {
      this.warning(
        "Variable name should start with a small letter", 
        WorkflowPackage.eINSTANCE.getVariable_Name(), 
        WorkflowValidator.VARIABLE_INVALID_NAME, 
        variable.getName());
    }
  }
  
  @Check
  public void checkUndefinedVariable(final Variable variable) {
    Expression _expression = variable.getExpression();
    if ((_expression instanceof VariableRef)) {
      final String varName = variable.getName();
      Expression _expression_1 = variable.getExpression();
      String varRefName = ((VariableRef) _expression_1).getVariable().getName();
      if ((varName == varRefName)) {
        this.warning(
          "Variable should be defined before its use", 
          null, varRefName);
      }
    }
  }
  
  @Check
  public void checkWorkflowNameStartsWithLowerLetter(final Workflow workflow) {
    boolean _isUpperCase = Character.isUpperCase(workflow.getName().charAt(0));
    if (_isUpperCase) {
      this.warning(
        "Workflow name should start with a small letter", 
        WorkflowPackage.eINSTANCE.getWorkflow_Name(), 
        WorkflowValidator.WORKFLOW_INVALID_NAME, 
        workflow.getName());
    }
  }
  
  @Check
  public void checkMethodStartsWithSmallLetter(final Method method) {
    boolean _isUpperCase = Character.isUpperCase(method.getName().charAt(0));
    if (_isUpperCase) {
      this.warning(
        "Method name should start with a small letter", 
        WorkflowPackage.eINSTANCE.getMethod_Name(), 
        WorkflowValidator.METHOD_INVALID_NAME, 
        method.getName());
    }
  }
  
  @Check
  public void checkMethodInvocationArguments(final MethodInvocation methodInvoc) {
    final Method method = methodInvoc.getInvokedMethod();
    int _size = method.getParams().size();
    int _size_1 = methodInvoc.getArgs().size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      int _size_2 = method.getParams().size();
      String _plus = ("Invalid number of arguments: expected " + Integer.valueOf(_size_2));
      String _plus_1 = (_plus + " but was ");
      int _size_3 = methodInvoc.getArgs().size();
      String _plus_2 = (_plus_1 + Integer.valueOf(_size_3));
      this.error(_plus_2, 
        WorkflowPackage.eINSTANCE.getMethodInvocation_InvokedMethod(), WorkflowValidator.INVALID_ARGS);
    }
  }
  
  @Check
  public void checkForwardReference(final VariableRef varRef) {
    final Variable variable = varRef.getVariable();
    String _name = variable.getName();
    boolean _tripleEquals = (_name == null);
    if (_tripleEquals) {
      String _name_1 = variable.getName();
      String _plus = ("variable forward reference not allowed: \'" + _name_1);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, 
        WorkflowPackage.eINSTANCE.getVariableRef_Variable(), 
        WorkflowValidator.FORWARD_REFERENCE, 
        variable.getName());
    }
  }
  
  @Check
  public void checkType(final Not not) {
    this.checkExpectedBoolean(not.getExpression(), WorkflowPackage.Literals.NOT__EXPRESSION);
  }
  
  @Check
  public void checkType(final And and) {
    this.checkExpectedBoolean(and.getLeft(), WorkflowPackage.Literals.AND__LEFT);
    this.checkExpectedBoolean(and.getRight(), WorkflowPackage.Literals.AND__RIGHT);
  }
  
  @Check
  public void checkType(final Or or) {
    this.checkExpectedBoolean(or.getLeft(), WorkflowPackage.Literals.OR__LEFT);
    this.checkExpectedBoolean(or.getRight(), WorkflowPackage.Literals.OR__RIGHT);
  }
  
  @Check
  public void checkType(final MulOrDiv mulOrDiv) {
    this.checkExpectedInt(mulOrDiv.getLeft(), WorkflowPackage.Literals.MUL_OR_DIV__LEFT);
    this.checkExpectedInt(mulOrDiv.getRight(), WorkflowPackage.Literals.MUL_OR_DIV__RIGHT);
  }
  
  @Check
  public void checkType(final Minus minus) {
    this.checkExpectedInt(minus.getLeft(), WorkflowPackage.Literals.MINUS__LEFT);
    this.checkExpectedInt(minus.getRight(), WorkflowPackage.Literals.MINUS__RIGHT);
  }
  
  @Check
  public void checkType(final Equality equality) {
    final ExpressionsType leftType = this.getTypeAndCheckNotNull(equality.getLeft(), WorkflowPackage.Literals.EQUALITY__LEFT);
    final ExpressionsType rightType = this.getTypeAndCheckNotNull(equality.getRight(), WorkflowPackage.Literals.EQUALITY__RIGHT);
    this.checkExpectedSame(leftType, rightType);
  }
  
  @Check
  public void checkType(final Comparison comparison) {
    final ExpressionsType leftType = this.getTypeAndCheckNotNull(comparison.getLeft(), WorkflowPackage.Literals.COMPARISON__LEFT);
    final ExpressionsType rightType = this.getTypeAndCheckNotNull(comparison.getRight(), WorkflowPackage.Literals.COMPARISON__RIGHT);
    this.checkExpectedSame(leftType, rightType);
    this.checkNotBoolean(leftType, WorkflowPackage.Literals.COMPARISON__LEFT);
    this.checkNotBoolean(rightType, WorkflowPackage.Literals.COMPARISON__RIGHT);
  }
  
  @Check
  public void checkType(final Plus plus) {
    final ExpressionsType leftType = this.getTypeAndCheckNotNull(plus.getLeft(), WorkflowPackage.Literals.PLUS__LEFT);
    final ExpressionsType rightType = this.getTypeAndCheckNotNull(plus.getRight(), WorkflowPackage.Literals.PLUS__RIGHT);
    if (((this._workflowTypeComputer.isIntType(leftType) || this._workflowTypeComputer.isIntType(rightType)) || ((!this._workflowTypeComputer.isStringType(leftType)) && (!this._workflowTypeComputer.isStringType(rightType))))) {
      this.checkNotBoolean(leftType, WorkflowPackage.Literals.PLUS__LEFT);
      this.checkNotBoolean(rightType, WorkflowPackage.Literals.PLUS__RIGHT);
    }
  }
  
  private void checkExpectedSame(final ExpressionsType left, final ExpressionsType right) {
    if ((((right != null) && (left != null)) && (!Objects.equal(right, left)))) {
      this.error(((("expected the same type, but was " + left) + ", ") + right), 
        WorkflowPackage.Literals.EQUALITY.getEIDAttribute(), WorkflowValidator.TYPE_MISMATCH);
    }
  }
  
  private void checkNotBoolean(final ExpressionsType type, final EReference reference) {
    boolean _isBoolType = this._workflowTypeComputer.isBoolType(type);
    if (_isBoolType) {
      this.error("cannot be boolean", reference, WorkflowValidator.TYPE_MISMATCH);
    }
  }
  
  private void checkExpectedBoolean(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, WorkflowTypeComputer.BOOL_TYPE, reference);
  }
  
  private void checkExpectedInt(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, WorkflowTypeComputer.INT_TYPE, reference);
  }
  
  private void checkExpectedType(final Expression exp, final ExpressionsType expectedType, final EReference reference) {
    final ExpressionsType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(
        ((("expected " + expectedType) + " type, but was ") + actualType), reference, 
        WorkflowValidator.TYPE_MISMATCH);
    }
  }
  
  private ExpressionsType getTypeAndCheckNotNull(final Expression exp, final EReference reference) {
    ExpressionsType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._workflowTypeComputer.typeFor(exp);
    }
    final ExpressionsType type = _typeFor;
    if ((type == null)) {
      this.error("null type", reference, WorkflowValidator.TYPE_MISMATCH);
    }
    return type;
  }
}
