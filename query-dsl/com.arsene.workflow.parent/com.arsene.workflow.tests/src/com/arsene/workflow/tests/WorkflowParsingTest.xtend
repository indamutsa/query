/*
 * generated by Xtext 2.25.0
 */
package com.arsene.workflow.tests

import com.arsene.workflow.workflow.And
import com.arsene.workflow.workflow.BoolConstant
import com.arsene.workflow.workflow.Comparison
import com.arsene.workflow.workflow.Equality
import com.arsene.workflow.workflow.Expression
import com.arsene.workflow.workflow.IntConstant
import com.arsene.workflow.workflow.Minus
import com.arsene.workflow.workflow.MulOrDiv
import com.arsene.workflow.workflow.Not
import com.arsene.workflow.workflow.Or
import com.arsene.workflow.workflow.Plus
import com.arsene.workflow.workflow.StringConstant
import com.arsene.workflow.workflow.VariableRef
import com.arsene.workflow.workflow.WorkflowProgramModel
import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

import static extension org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(WorkflowInjectorProvider)
class WorkflowParsingTest {

	@Inject extension ParseHelper<WorkflowProgramModel>
	@Inject extension ValidationTestHelper

	@Test
	def void loadModel() {
		val result = '''
			Workflow myWorkflow type: Sequence
			{
				step "first step"{
					var arsene = "Hello world"
				}
			};
		'''.parse
		val workflow = result.features.head.workflow.name

		assertEquals("myWorkflow", workflow)
	}

	// We are making sure the parse takes care of the scoping
	// arsene variable is declared twice and the parser is not complaining
	@Test
	def void testCorrectParsing() {
		'''
			var name = "dsfjlsj"
			
			var arsene = "djfkdsjf"
			
			
			
			function method(){
				var a = "dksjfks"
			}
			
			
			
			Workflow myWorkflow type:parallel{
				step "HELLO"{
					var arsene = "dksjfk"
				}
			}
			Execute myWorkflow()
		'''.parse.assertNoErrors
	}

	@Test
	def void testWorkflowLowercaseName() {
		'''
			Workflow Myworkflow type:parallel{
				step "Build"{
					var internal_var = 2	
				}
			}
			
			
			Execute Myworkflow()
		'''.parse.assertWorkflowNoError

	}

	@Test
	def void testWorklow() {
		'''
			function method()
			{
				var arsene = 2
				return arsene
			}
			
			Workflow myWorkflow type:parallel{
				step "HELLO"{
					var i = 0
					var arsene = "dksjfk"
					loop: if(i <= 5){
						var a = "" 
						a = call method()
						i = a
					}
				}
			}
			
			Execute myWorkflow()
		'''.parse.assertNoErrors
	}

	def private assertWorkflowNoError(WorkflowProgramModel m) {
		m.assertNoErrors
	}

	@Test
	def void testFunction() {
		'''
			function method(string: name, number : e){
				var b = name
				var a = name + e
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testFunctionParam() {
		'''
			function method(string: name, number : e){
				var b = name
				var a = name + e
			}
			
			var a = "Hello new york"
			var b = "Hello world"
			call method(a, b)
		'''.parse.assertNoErrors
	}

	@Test
	def void testAnotherFunction() {
		'''
			function name(string : myName, number : c){
				print("Hello world" + myName)
				
				if(4 == 4){
					print("Yes")
					var b = 4
					var d = 5
					var e = b + d + c
				} else{
					print("No")
				}
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testMoreFeatures() {
		'''
			var arsene = ""
			var etl = "
			pre {
				parameterPassedFromJava.println();
			}
			
			rule Tree2Tree
				transform s : Source!Tree
				to t : Target!Tree {
				
				t.label := 'CopyOf' + s.label;
				t.children ::= s.children;
				
			}
			"
			var hello = "jdksjakdj"
			
			«««			Artifact sourceModel = type: Xmi, link: "http://localhost:8085/tree.xmi"
«««			Artifact sourceMetaModel = type: Ecore, link: "http://localhost:8085/tree.ecore"
«««			Artifact targetModel = type: Xmi, link: "http://localhost:8085/tree.xmi"
«««			Artifact targetMetaModel = type: Ecore, link: "http://localhost:8085/tree.ecore"
«««			Artifact etlScript = type: Etl, content: etl
			
			
			
			var name = "Hello world"
			
			
			var a	= ""
			
			function method(){
				var a = 2
				return a 
			}
			
			Workflow myW	rkflow type:paral	rl{
				step "	irst	step"{
					var name = 	s					var i = 0
				
					loop: if(i <= 	s){
			s		 i	s i + 1
						a = call method()
					}
					
«««					service _transfo( ) 
				}
			}
			Execute myWorkflow()
		'''.parse.assertNoErrors
	}

	@Test
	def void workflowTest() {
		'''
			function method(){
				var a = 2
				return a 
			}
			«««			var b = ""
			var b = call method()
		'''.parse.assertNoErrors

	}

	@Test
	def void testFunctionAssignment() {
		'''
			Workflow myWorkflow type:parallel{
				step "first step"{
					var name = 5
				}
			}
			Execute myWorkflow()
		'''.parse.assertNoErrors

	}

	@Test
	def void workflowTestSomething() {
		'''
			Workflow myWorkflow type:parallel{
				step "first step"{
					var name = 5
				}
			}
			Execute myWorkflow()
		'''.parse.assertNoErrors

	}

	// your_string= your_string.replaceAll("\\s*,\\s*", ",");
	@Test
	def void testVariable() {
		"var i = 10".parse.assertNotNull
	}

	@Test def void testPrintIntConstant() {
		"print(10)".parse.assertNotNull
	}

	@Test def void testPrintStringConstant() {
		'print("a string")'.parse.assertNotNull
	}

	@Test def void testEvalBoolConstant() {
		"print(true)".parse.assertNotNull
	}

	@Test
	def void testVariableReference() {
		'''
			var i = 10
			print(i)
		'''.parse => [
			(features.last.statement.print.expression as VariableRef
			).variable.assertSame(features.head.statement.variabl)
		]
	}

//	 Test an assignment
	@Test
	def void testAssignment() {
		'''
			var i = 5
			var j = 2
			i = j
		'''.parse.assertNoErrors
	}

//	@Test
//	def void testArtifactVariable(){
//		'''
//			Define Artifact nameArtifact = type: Ecore, link: "path"
//		'''.parse => [
//			print(features.head.statement)
//		]
//	}
	@Test
	def void testParenthesis() {
		10.assertEquals(
			("print(10)".parse.features.head.statement.print.expression as IntConstant).value
		)
	}

	@Test
	def void testPlusWithParenthesis() {
		"( 10 + 5 ) + ( 1 + 2 )".assertSolution("((10 + 5) + (1 + 2))")
	}

	@Test
	def void testMinus() {
		"10 + 5 - 1 - 2".assertSolution("(((10 + 5) - 1) - 2)")
	}

	@Test
	def void testMulOrDiv() {
		"10 * 5 / 1 * 2".assertSolution("(((10 * 5) / 1) * 2)")
	}

	@Test
	def void testPlusMulPrecedence() {
		"10 + 5 * 2 - 5 / 1".assertSolution("((10 + (5 * 2)) - (5 / 1))")
	}

	@Test
	def void testComparison() {
		"10 <= 5 < 2 > 5".assertSolution("(((10 <= 5) < 2) > 5)")
	}

	@Test def void testEqualityAndComparison() {
		"true == 5 <= 2".assertSolution("(true == (5 <= 2))")
	}

	@Test def void testAndOr() {
		"true or false and 1 < 0".assertSolution("(true or (false and (1 < 0)))")
	}

	@Test def void testNot() {
		"!true or false".assertSolution("((!true) or false)")
	}

	@Test def void testNotWithParentheses() {
		"!(true or false)".assertSolution("(!(true or false))")
	}

	@Test def void testPrecedences() {
		"!true or false and 1 >(1/3+5*2)".assertSolution("((!true) or (false and (1 > ((1 / 3) + (5 * 2)))))")
	}

	def private assertSolution(CharSequence m, CharSequence expected) {
		("print(" + m + ")").parse => [
			expected.assertEquals(
				features.last.statement.print.expression.stringRepr
			)
		]
	}

	def private String stringRepr(Expression e) {

		switch (e) {
			Plus: '''(«e.left.stringRepr» + «e.right.stringRepr»)'''
			Minus: '''(«e.left.stringRepr» - «e.right.stringRepr»)'''
			MulOrDiv: '''(«e.left.stringRepr» «e.op» «e.right.stringRepr»)'''
			Comparison: '''(«e.left.stringRepr» «e.op» «e.right.stringRepr»)'''
			Equality: '''(«e.left.stringRepr» «e.op» «e.right.stringRepr»)'''
			And: '''(«e.left.stringRepr» and «e.right.stringRepr»)'''
			Or: '''(«e.left.stringRepr» or «e.right.stringRepr»)'''
			Not: '''(!«e.expression.stringRepr»)'''
			IntConstant: '''«e.value»'''
			StringConstant: '''«e.value»'''
			BoolConstant: '''«e.value»'''
			VariableRef: '''«e.variable.name»'''
		}.toString
	}

}
